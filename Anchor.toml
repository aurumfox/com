use anchor_lang::prelude::*;
use anchor_spl::token::{self, Mint, Token, TokenAccount, Transfer};
use std::convert::TryInto;

declare_id!("FJ4uiPLTdzjMoERxzCAWpagxp23MFrTE8DGCzj2A5qzjK");

const BPS_DENOMINATOR: u128 = 10000;
const RPS_MULTIPLIER: u128 = 100_000_000; 
const REWARD_RATE_PER_SEC: u128 = 100;
const GOVERNANCE_LOCK_SECONDS: i64 = 7 * 24 * 60 * 60;
const LENDING_UNLOCK_GRACE_SECONDS: i64 = 30 * 24 * 60 * 60;
const EARLY_EXIT_FEE_BPS: u16 = 4000;
const DAO_CAP_RESET_SECONDS: i64 = 24 * 60 * 60;
const MIN_INITIAL_STAKE: u64 = 10_000_000_000; 

#[program]
pub mod my-new-afox-project { 
    use super::*;

    pub fn initialize_pool(
        ctx: Context<InitializePool>,
        pool_bump: u8,
        max_dao_withdrawal_amount: u64,
        admin_fee_share_bps: u16,
        lockup_seconds: [i64; 3],
        sweep_threshold: u64,
    ) -> Result<()> {
        let pool = &mut ctx.accounts.pool_state.load_init()?;
        let current_time = ctx.accounts.clock.unix_timestamp;

        require!(!lockup_seconds.is_empty(), ErrorCode::InvalidInput);
        for lockup in lockup_seconds.iter() {
            require!(*lockup >= 0, ErrorCode::InvalidInput);
        }
        require!(admin_fee_share_bps <= BPS_DENOMINATOR.try_into().unwrap(), ErrorCode::InvalidInput);

        require!(!ctx.accounts.governance_authority.to_account_info().executable, ErrorCode::InvalidInput);
        require!(!ctx.accounts.admin_authority.to_account_info().executable, ErrorCode::InvalidInput);
        require!(!ctx.accounts.lending_authority.to_account_info().executable, ErrorCode::InvalidInput);

        require!(ctx.accounts.governance_authority.key() != Pubkey::default(), ErrorCode::InvalidInput);
        require!(ctx.accounts.admin_authority.key() != Pubkey::default(), ErrorCode::InvalidInput);
        require!(ctx.accounts.lending_authority.key() != Pubkey::default(), ErrorCode::InvalidInput);
        
        pool.pool_bump = pool_bump;
        pool.vault_bump = ctx.bumps.vault;
        pool.admin_fee_vault_bump = ctx.bumps.admin_fee_vault;
        pool.dao_treasury_vault_bump = ctx.bumps.dao_treasury_vault;
        pool.defaulter_treasury_vault_bump = ctx.bumps.defaulter_treasury_vault;

        pool.governance_authority = ctx.accounts.governance_authority.key();
        pool.admin_authority = ctx.accounts.admin_authority.key();
        pool.lending_authority = ctx.accounts.lending_authority.key();
        
        pool.max_dao_withdrawal_amount = max_dao_withdrawal_amount;
        pool.admin_fee_share_bps = admin_fee_share_bps;
        pool.lockup_seconds = lockup_seconds;
        pool.sweep_threshold = sweep_threshold;

        pool.is_initialized = true;
        pool.global_pause = false;
        pool.reward_mint = ctx.accounts.reward_mint.key();
        pool.vault = ctx.accounts.vault.key();
        pool.admin_fee_vault = ctx.accounts.admin_fee_vault.key();
        pool.dao_treasury_vault = ctx.accounts.dao_treasury_vault.key();
        pool.defaulter_treasury_vault = ctx.accounts.defaulter_treasury_vault.key();

        pool.reward_per_share_global = 0;
        pool.total_staked_amount = 0;
        pool.total_unclaimed_rewards = 0;
        pool.last_reward_time = current_time;
        pool.dao_withdrawal_24h_cap = 0;
        
        pool.dao_withdrawal_reset_time = current_time.checked_add(DAO_CAP_RESET_SECONDS).ok_or(ErrorCode::MathOverflow)?;

        Ok(())
    }

    pub fn set_pause(ctx: Context<SetPause>, global_pause: bool) -> Result<()> {
        let pool = &mut ctx.accounts.pool_state.load_mut()?;
        pool.global_pause = global_pause;
        Ok(())
    }

    pub fn set_pending_change(ctx: Context<SetPendingChange>, new_authority: Pubkey) -> Result<()> {
        let pool = &mut ctx.accounts.pool_state.load_mut()?;
        require!(!pool.global_pause, ErrorCode::GlobalPause);

        require!(!ctx.accounts.new_authority_info.executable, ErrorCode::InvalidInput);
        require!(new_authority != Pubkey::default(), ErrorCode::InvalidInput);

        pool.pending_governance_authority = new_authority;
        pool.pending_change_time = ctx.accounts.clock.unix_timestamp;

        Ok(())
    }

    pub fn claim_pending_change(ctx: Context<ClaimPendingChange>) -> Result<()> {
        let pool = &mut ctx.accounts.pool_state.load_mut()?;
        require!(!pool.global_pause, ErrorCode::GlobalPause);

        require!(pool.pending_governance_authority != Pubkey::default(), ErrorCode::NoPendingChange);
        require!(ctx.accounts.clock.unix_timestamp >= pool.pending_change_time.checked_add(GOVERNANCE_LOCK_SECONDS).ok_or(ErrorCode::MathOverflow)?, ErrorCode::TimeLockNotExpired);

        require!(ctx.accounts.claiming_authority.key() == pool.pending_governance_authority, ErrorCode::Unauthorized);
        
        pool.governance_authority = pool.pending_governance_authority;
        pool.pending_governance_authority = Pubkey::default();
        pool.pending_change_time = 0;
        
        Ok(())
    }
    
    pub fn sweep_vault(ctx: Context<SweepVault>, amount: u64) -> Result<()> {
        let pool = ctx.accounts.pool_state.load()?;
        require!(!pool.global_pause, ErrorCode::GlobalPause);
        require!(amount > 0, ErrorCode::ZeroAmount);
        
        require!(ctx.accounts.vault.key() != ctx.accounts.dao_treasury_vault.key(), ErrorCode::DuplicateVaults);

        let vault_balance = ctx.accounts.vault.amount;
        
        let min_safe_balance = pool.total_staked_amount
            .checked_add(pool.total_unclaimed_rewards).ok_or(ErrorCode::MathOverflow)?;

        let max_safe_balance = min_safe_balance.checked_add(pool.sweep_threshold).ok_or(ErrorCode::MathOverflow)?;

        require!(vault_balance > max_safe_balance, ErrorCode::InsufficientVaultBalance);
        let sweepable_amount = vault_balance.checked_sub(max_safe_balance).ok_or(ErrorCode::MathUnderflow)?;
        require!(amount <= sweepable_amount, ErrorCode::AmountTooLarge);
        
        __transfer_from_pool_authority(
            ctx.accounts.token_program,
            ctx.accounts.pool_state.to_account_info(),
            ctx.accounts.vault.to_account_info(), 
            ctx.accounts.dao_treasury_vault.to_account_info(),
            pool.pool_bump,
            amount,
        )?;

        Ok(())
    }

    pub fn withdraw_from_dao_treasury(ctx: Context<WithdrawFromDaoTreasury>, amount: u64) -> Result<()> {
        let pool = ctx.accounts.pool_state.load()?;
        require!(!pool.global_pause, ErrorCode::GlobalPause);
        require!(amount > 0, ErrorCode::ZeroAmount);
        require!(ctx.accounts.dao_treasury_vault.amount >= amount, ErrorCode::InsufficientVaultBalance);

        __transfer_from_pool_authority(
            ctx.accounts.token_program,
            ctx.accounts.pool_state.to_account_info(),
            ctx.accounts.dao_treasury_vault.to_account_info(), 
            ctx.accounts.destination_ata.to_account_info(),
            pool.pool_bump,
            amount,
        )?;
        
        Ok(())
    }

    pub fn withdraw_from_admin_fee(ctx: Context<WithdrawFromAdminFee>, amount: u64) -> Result<()> {
        let pool = ctx.accounts.pool_state.load()?;
        require!(!pool.global_pause, ErrorCode::GlobalPause);
        require!(amount > 0, ErrorCode::ZeroAmount);
        require!(ctx.accounts.admin_fee_vault.amount >= amount, ErrorCode::InsufficientVaultBalance);

        __transfer_from_pool_authority(
            ctx.accounts.token_program,
            ctx.accounts.pool_state.to_account_info(),
            ctx.accounts.admin_fee_vault.to_account_info(), 
            ctx.accounts.destination_ata.to_account_info(),
            pool.pool_bump,
            amount,
        )?;
        
        Ok(())
    }

    pub fn initialize_user_stake(ctx: Context<InitializeUserStake>, pool_index: u8) -> Result<()> {
        let pool = ctx.accounts.pool_state.load()?;
        require!(!pool.global_pause, ErrorCode::GlobalPause);
        require!((pool_index as usize) < pool.lockup_seconds.len(), ErrorCode::InvalidPoolIndex);

        let user_staking = &mut ctx.accounts.user_staking.load_init()?;
        let current_time = ctx.accounts.clock.unix_timestamp;
        
        user_staking.owner = ctx.accounts.owner.key(); 
        user_staking.stake_bump = ctx.bumps.user_staking;
        user_staking.pool_index = pool_index;
        user_staking.is_initialized = true;
        user_staking.last_update_time = current_time;
        user_staking.reward_per_share_user = pool.reward_per_share_global;
        
        let lockup_duration = pool.lockup_seconds[pool_index as usize];
        user_staking.lockup_end_time = current_time.checked_add(lockup_duration).ok_or(ErrorCode::MathOverflow)?;

        Ok(())
    }

    pub fn deposit(ctx: Context<Deposit>, amount: u64) -> Result<()> {
        let current_time = ctx.accounts.clock.unix_timestamp;
        let mut pool = ctx.accounts.pool_state.load_mut()?;
        let mut user_staking = ctx.accounts.user_staking.load_mut()?;
        
        require!(!pool.global_pause, ErrorCode::GlobalPause);
        require!(amount > 0, ErrorCode::ZeroAmount);
        
        require!(ctx.accounts.user_source_ata.key() != ctx.accounts.vault.key(), ErrorCode::DuplicateVaults);

        if pool.total_staked_amount == 0 && user_staking.staked_amount == 0 {
             require!(amount >= MIN_INITIAL_STAKE, ErrorCode::InitialStakeTooSmall);
        }
        
        __accrue_rewards_mut(&mut pool, &mut user_staking, current_time)?;

        if user_staking.staked_amount == 0 {
            let lockup_duration = pool.lockup_seconds[user_staking.pool_index as usize];
            user_staking.lockup_end_time = current_time.checked_add(lockup_duration).ok_or(ErrorCode::MathOverflow)?;
        }
        
        __transfer_to_vault(
            ctx.accounts.token_program,
            ctx.accounts.owner.to_account_info(),
            ctx.accounts.user_source_ata.to_account_info(),
            ctx.accounts.vault.to_account_info(),
            amount,
        )?;
        
        user_staking.staked_amount = user_staking.staked_amount.checked_add(amount).ok_or(ErrorCode::MathOverflow)?;
        pool.total_staked_amount = pool.total_staked_amount.checked_add(amount).ok_or(ErrorCode::MathOverflow)?;

        Ok(())
    }

    pub fn update_user_pool_duration(ctx: Context<UpdateUserPoolDuration>, new_pool_index: u8) -> Result<()> {
        let current_time = ctx.accounts.clock.unix_timestamp;
        let mut pool = ctx.accounts.pool_state.load_mut()?;
        let mut user_staking = ctx.accounts.user_staking.load_mut()?;
        
        require!(!pool.global_pause, ErrorCode::GlobalPause);
        require!(user_staking.staked_amount > 0, ErrorCode::ZeroStakedAmount);
        require!((new_pool_index as usize) < pool.lockup_seconds.len(), ErrorCode::InvalidPoolIndex);
        
        let new_lockup_seconds = pool.lockup_seconds[new_pool_index as usize];
        let current_lockup_seconds = pool.lockup_seconds[user_staking.pool_index as usize];
        
        if new_lockup_seconds < current_lockup_seconds {
            return Err(ErrorCode::LockupTooShort.into());
        }

        if new_lockup_seconds == current_lockup_seconds && current_time < user_staking.lockup_end_time {
             return Err(ErrorCode::LockupStillActive.into());
        }

        __accrue_rewards_mut(&mut pool, &mut user_staking, current_time)?;

        user_staking.pool_index = new_pool_index;
        user_staking.lockup_end_time = current_time.checked_add(new_lockup_seconds).ok_or(ErrorCode::MathOverflow)?;

        Ok(())
    }

    pub fn claim_rewards(ctx: Context<ClaimRewards>) -> Result<()> {
        let current_time = ctx.accounts.clock.unix_timestamp;
        
        require!(ctx.accounts.vault.key() != ctx.accounts.admin_fee_vault.key(), ErrorCode::DuplicateVaults);
        
        let mut pool = ctx.accounts.pool_state.load_mut()?;
        let mut user_staking = ctx.accounts.user_staking.load_mut()?;
        
        require!(!pool.global_pause, ErrorCode::GlobalPause);

        __accrue_rewards_mut(&mut pool, &mut user_staking, current_time)?;
        
        let mut dao_cap_reset = false;
        if current_time >= pool.dao_withdrawal_reset_time {
            dao_cap_reset = true;
        }
        
        let total_rewards_to_claim = user_staking.rewards_to_claim;
        let total_pending_limit = user_staking.pending_rewards_due_to_limit;
        
        let total_claimable_rewards_before_limit = total_rewards_to_claim.checked_add(total_pending_limit).ok_or(ErrorCode::MathOverflow)?;
        
        require!(total_claimable_rewards_before_limit > 0, ErrorCode::ZeroAmount); 

        let admin_reward_share = (total_claimable_rewards_before_limit as u128)
            .checked_mul(pool.admin_fee_share_bps as u128).ok_or(ErrorCode::MathOverflow)?
            .checked_div(BPS_DENOMINATOR).ok_or(ErrorCode::MathOverflow)?
            .try_into().map_err(|_| ErrorCode::MathOverflow)?;

        let rewards_to_user_and_limit = total_claimable_rewards_before_limit.checked_sub(admin_reward_share).ok_or(ErrorCode::MathUnderflow)?;

        let dao_withdrawal_limit = pool.max_dao_withdrawal_amount;
        let current_dao_cap = if dao_cap_reset { 0 } else { pool.dao_withdrawal_24h_cap };

        let available_dao_withdrawal = dao_withdrawal_limit
            .checked_sub(current_dao_cap).ok_or(ErrorCode::MathUnderflow)?;

        let claimable_amount_user = available_dao_withdrawal.min(rewards_to_user_and_limit);
        
        if claimable_amount_user == 0 && admin_reward_share == 0 && rewards_to_user_and_limit > 0 {
             return Err(ErrorCode::DaoLimitReached.into());
        }
        
        let total_transfer_out = claimable_amount_user.checked_add(admin_reward_share).ok_or(ErrorCode::MathOverflow)?;
        require!(ctx.accounts.vault.amount >= total_transfer_out, ErrorCode::InsufficientVaultBalance);

        let pool_bump = pool.pool_bump;
        let pool_info = ctx.accounts.pool_state.to_account_info();
        let vault_info = ctx.accounts.vault.to_account_info();
        
        if admin_reward_share > 0 {
            __transfer_from_pool_authority(
                ctx.accounts.token_program,
                pool_info.clone(),
                vault_info.clone(),
                ctx.accounts.admin_fee_vault.to_account_info(),
                pool_bump,
                admin_reward_share,
            )?;
        }
        
        if claimable_amount_user > 0 {
            __transfer_from_pool_authority(
                ctx.accounts.token_program,
                pool_info,
                vault_info,
                ctx.accounts.user_rewards_ata.to_account_info(),
                pool_bump,
                claimable_amount_user,
            )?;
        }
        
        if dao_cap_reset {
            let time_past_due = current_time.checked_sub(pool.dao_withdrawal_reset_time).ok_or(ErrorCode::MathUnderflow)?;
            let num_intervals_to_advance = time_past_due.checked_div(DAO_CAP_RESET_SECONDS).ok_or(ErrorCode::MathOverflow)?;
            
            pool.dao_withdrawal_reset_time = pool.dao_withdrawal_reset_time
                .checked_add(num_intervals_to_advance.checked_add(1).ok_or(ErrorCode::MathOverflow)?
                .checked_mul(DAO_CAP_RESET_SECONDS).ok_or(ErrorCode::MathOverflow)?)
                .ok_or(ErrorCode::MathOverflow)?;
            
            pool.dao_withdrawal_24h_cap = 0;
        }
        pool.dao_withdrawal_24h_cap = pool.dao_withdrawal_24h_cap
            .checked_add(claimable_amount_user).ok_or(ErrorCode::MathOverflow)?;

        pool.total_unclaimed_rewards = pool.total_unclaimed_rewards
            .checked_sub(total_transfer_out).ok_or(ErrorCode::MathUnderflow)?;
            
        let total_rewards_not_claimed = rewards_to_user_and_limit.checked_sub(claimable_amount_user).ok_or(ErrorCode::MathUnderflow)?;
        
        user_staking.rewards_to_claim = 0;
        user_staking.pending_rewards_due_to_limit = total_rewards_not_claimed;
        
        Ok(())
    }

    pub fn unstake(ctx: Context<Unstake>, amount: u64, is_early_exit: bool) -> Result<()> {
        let current_time = ctx.accounts.clock.unix_timestamp;
        
        require!(ctx.accounts.vault.key() != ctx.accounts.dao_treasury_vault.key(), ErrorCode::DuplicateVaults);
        require!(ctx.accounts.vault.key() != ctx.accounts.admin_fee_vault.key(), ErrorCode::DuplicateVaults);

        let mut pool = ctx.accounts.pool_state.load_mut()?;
        let mut user_staking = ctx.accounts.user_staking.load_mut()?;
        
        require!(!pool.global_pause, ErrorCode::GlobalPause);
        require!(amount > 0, ErrorCode::ZeroAmount);
        
        let non_collateralized_stake = user_staking.staked_amount.checked_sub(user_staking.lending).ok_or(ErrorCode::MathUnderflow)?;
        require!(non_collateralized_stake >= amount, ErrorCode::CollateralLock);
        
        if user_staking.lending > 0 {
            require!(current_time < user_staking.lending_unlock_time, ErrorCode::CollateralLockedAtRisk);
        }

        __accrue_rewards_mut(&mut pool, &mut user_staking, current_time)?;
        
        let mut transfer_amount = amount;
        let mut total_fee_or_seized = 0;
        let mut admin_fee_share_total = 0;
        
        let total_rewards_to_clear = user_staking.rewards_to_claim
            .checked_add(user_staking.pending_rewards_due_to_limit).ok_or(ErrorCode::MathOverflow)?;

        if !is_early_exit {
            require!(current_time >= user_staking.lockup_end_time, ErrorCode::LockupNotExpired);
            
            if total_rewards_to_clear > 0 {
                total_fee_or_seized = total_rewards_to_clear;
            }
            
        } else {
            
            let fee_paid = (amount as u128)
                .checked_mul(EARLY_EXIT_FEE_BPS as u128).ok_or(ErrorCode::MathOverflow)?
                .checked_div(BPS_DENOMINATOR).ok_or(ErrorCode::MathOverflow)?
                .try_into().map_err(|_| ErrorCode::MathOverflow)?;

            transfer_amount = amount.checked_sub(fee_paid).ok_or(ErrorCode::MathUnderflow)?;
            
            let admin_fee = (fee_paid as u128)
                .checked_mul(pool.admin_fee_share_bps as u128).ok_or(ErrorCode::MathOverflow)?
                .checked_div(BPS_DENOMINATOR).ok_or(ErrorCode::MathOverflow)?
                .try_into().map_err(|_| ErrorCode::MathOverflow)?;
            
            let dao_fee = fee_paid.checked_sub(admin_fee).ok_or(ErrorCode::MathUnderflow)?;
            
            admin_fee_share_total = admin_fee;
            total_fee_or_seized = dao_fee.checked_add(total_rewards_to_clear).ok_or(ErrorCode::MathOverflow)?;
        }

        let total_transfer = transfer_amount
            .checked_add(admin_fee_share_total).ok_or(ErrorCode::MathOverflow)?
            .checked_add(total_fee_or_seized).ok_or(ErrorCode::MathOverflow)?;
            
        require!(ctx.accounts.vault.amount >= total_transfer, ErrorCode::InsufficientVaultBalance);

        let pool_bump = pool.pool_bump;
        let pool_info = ctx.accounts.pool_state.to_account_info();
        let vault_info = ctx.accounts.vault.to_account_info();

        if admin_fee_share_total > 0 {
             __transfer_from_pool_authority(
                ctx.accounts.token_program,
                pool_info.clone(),
                vault_info.clone(),
                ctx.accounts.admin_fee_vault.to_account_info(),
                pool_bump,
                admin_fee_share_total,
            )?;
        }
        
        if total_fee_or_seized > 0 {
            __transfer_from_pool_authority(
                ctx.accounts.token_program,
                pool_info.clone(),
                vault_info.clone(),
                ctx.accounts.dao_treasury_vault.to_account_info(),
                pool_bump,
                total_fee_or_seized,
            )?;
        }
        
        if transfer_amount > 0 {
            __transfer_from_pool_authority(
                ctx.accounts.token_program,
                pool_info,
                vault_info,
                ctx.accounts.user_rewards_ata.to_account_info(),
                pool_bump,
                transfer_amount,
            )?;
        }

        user_staking.staked_amount = user_staking.staked_amount.checked_sub(amount).ok_or(ErrorCode::MathUnderflow)?;
        pool.total_staked_amount = pool.total_staked_amount.checked_sub(amount).ok_or(ErrorCode::MathUnderflow)?;
        
        pool.total_unclaimed_rewards = pool.total_unclaimed_rewards
            .checked_sub(total_rewards_to_clear).ok_or(ErrorCode::MathUnderflow)?;
            
        user_staking.rewards_to_claim = 0;
        user_staking.pending_rewards_due_to_limit = 0;

        if user_staking.staked_amount == 0 {
            user_staking.lockup_end_time = 0;
            user_staking.lending = 0; 
            user_staking.lending_unlock_time = 0;
            user_staking.last_update_time = current_time;
        }

        Ok(())
    }

    pub fn close_staking_account(ctx: Context<CloseStakingAccount>) -> Result<()> {
        let current_time = ctx.accounts.clock.unix_timestamp;
        
        let mut pool = ctx.accounts.pool_state.load_mut()?;
        let mut user_staking = ctx.accounts.user_staking.load_mut()?;

        __accrue_rewards_mut(&mut pool, &mut user_staking, current_time)?;

        require!(user_staking.staked_amount == 0, ErrorCode::StakeStillExists);
        require!(user_staking.lending == 0, ErrorCode::CollateralLock);
        
        let total_rewards_to_clear = user_staking.rewards_to_claim
            .checked_add(user_staking.pending_rewards_due_to_limit).ok_or(ErrorCode::MathOverflow)?;

        if total_rewards_to_clear > 0 {
             pool.total_unclaimed_rewards = pool.total_unclaimed_rewards
                .checked_sub(total_rewards_to_clear).ok_or(ErrorCode::MathUnderflow)?;
        }
        
        user_staking.rewards_to_claim = 0;
        user_staking.pending_rewards_due_to_limit = 0;
        
        Ok(())
    }

    pub fn collateralize_lending(ctx: Context<CollateralizeLending>, new_lending_amount: u64) -> Result<()> {
        let pool_loader = ctx.accounts.pool_state.load()?;
        require!(!pool_loader.global_pause, ErrorCode::GlobalPause);
        
        let user_staking_loader = ctx.accounts.user_staking.load()?;
        require!(user_staking_loader.staked_amount >= new_lending_amount, ErrorCode::InsufficientStake);
        
        if new_lending_amount > user_staking_loader.lending && user_staking_loader.lending > 0 {
             require!(ctx.accounts.clock.unix_timestamp < user_staking_loader.lending_unlock_time, ErrorCode::GracePeriodExpired);
        }

        drop(user_staking_loader);

        let mut user_staking = ctx.accounts.user_staking.load_mut()?;
        let current_time = ctx.accounts.clock.unix_timestamp;

        user_staking.lending = new_lending_amount;
        
        if new_lending_amount > 0 {
            user_staking.lending_unlock_time = current_time.checked_add(LENDING_UNLOCK_GRACE_SECONDS).ok_or(ErrorCode::MathOverflow)?;
        } else {
            user_staking.lending_unlock_time = 0;
        }

        Ok(())
    }

    pub fn decollateralize_lending(ctx: Context<DecollateralizeLending>, amount: u64) -> Result<()> {
        let pool_loader = ctx.accounts.pool_state.load()?;
        require!(!pool_loader.global_pause, ErrorCode::GlobalPause);
        
        let mut user_staking = ctx.accounts.user_staking.load_mut()?;
        let current_time = ctx.accounts.clock.unix_timestamp;
        
        require!(amount > 0, ErrorCode::ZeroAmount);
        require!(user_staking.lending >= amount, ErrorCode::InsufficientCollateral);
        
        require!(current_time < user_staking.lending_unlock_time, ErrorCode::GracePeriodExpired);

        user_staking.lending = user_staking.lending.checked_sub(amount).ok_or(ErrorCode::MathUnderflow)?;

        if user_staking.lending == 0 {
            user_staking.lending_unlock_time = 0;
        }

        Ok(())
    }

    pub fn force_unlock_collateral(ctx: Context<ForceUnlockCollateral>) -> Result<()> {
        let current_time = ctx.accounts.clock.unix_timestamp;
        
        require!(ctx.accounts.vault.key() != ctx.accounts.defaulter_treasury_vault.key(), ErrorCode::DuplicateVaults);

        let mut pool = ctx.accounts.pool_state.load_mut()?;
        let mut user_staking = ctx.accounts.user_staking.load_mut()?;
        
        require!(!pool.global_pause, ErrorCode::GlobalPause);
        require!(user_staking.lending > 0, ErrorCode::ZeroCollateral);
        
        require!(current_time >= user_staking.lending_unlock_time, ErrorCode::GracePeriodNotExpired);
        
        __accrue_rewards_mut(&mut pool, &mut user_staking, current_time)?;

        let collateral_seized = user_staking.lending;
        
        let rewards_seized = user_staking.rewards_to_claim
            .checked_add(user_staking.pending_rewards_due_to_limit).ok_or(ErrorCode::MathOverflow)?;

        let total_seized = collateral_seized.checked_add(rewards_seized).ok_or(ErrorCode::MathOverflow)?;
        require!(total_seized > 0, ErrorCode::ZeroAmount); 
        require!(ctx.accounts.vault.amount >= total_seized, ErrorCode::InsufficientVaultBalance);

        let pool_bump = pool.pool_bump;
        
        __transfer_from_pool_authority(
            ctx.accounts.token_program,
            ctx.accounts.pool_state.to_account_info(),
            ctx.accounts.vault.to_account_info(), 
            ctx.accounts.defaulter_treasury_vault.to_account_info(),
            pool_bump,
            total_seized,
        )?;

        pool.total_staked_amount = pool.total_staked_amount.checked_sub(collateral_seized).ok_or(ErrorCode::MathUnderflow)?;
        
        pool.total_unclaimed_rewards = pool.total_unclaimed_rewards
            .checked_sub(rewards_seized).ok_or(ErrorCode::MathUnderflow)?;

        user_staking.staked_amount = user_staking.staked_amount.checked_sub(collateral_seized).ok_or(ErrorCode::MathUnderflow)?;
        user_staking.lending = 0;
        user_staking.lending_unlock_time = 0;
        user_staking.rewards_to_claim = 0;
        user_staking.pending_rewards_due_to_limit = 0;
        user_staking.last_update_time = current_time;

        if user_staking.staked_amount == 0 {
            user_staking.lockup_end_time = 0;
        }

        Ok(())
    }

}

fn __accrue_rewards_mut(
    pool: &mut anchor_lang::solana_program::account_info::Account<PoolState>, 
    user_staking: &mut anchor_lang::solana_program::account_info::Account<UserStakingAccount>, 
    current_time: i64,
) -> Result<()> {
    
    let time_delta = current_time
        .checked_sub(pool.last_reward_time).ok_or(ErrorCode::MathUnderflow)?;
    
    let total_staked_u128 = pool.total_staked_amount as u128; 

    if time_delta > 0 && total_staked_u128 > 0 {
        let time_delta_u128 = time_delta.try_into().map_err(|_| ErrorCode::MathOverflow)?;

        let new_rewards_global = time_delta_u128
            .checked_mul(REWARD_RATE_PER_SEC).ok_or(ErrorCode::MathOverflow)?
            .checked_mul(RPS_MULTIPLIER).ok_or(ErrorCode::MathOverflow)?;
            
        let rps_increase = new_rewards_global
            .checked_div(total_staked_u128).ok_or(ErrorCode::MathOverflow)?;
        
        pool.reward_per_share_global = pool.reward_per_share_global
            .checked_add(rps_increase).ok_or(ErrorCode::MathOverflow)?;

        pool.last_reward_time = current_time;
    } 

    let user_staked_u128 = user_staking.staked_amount as u128;
    if user_staked_u128 > 0 {
        let rps_delta = pool.reward_per_share_global
            .checked_sub(user_staking.reward_per_share_user).ok_or(ErrorCode::MathUnderflow)?;

        let new_rewards_u128 = rps_delta
            .checked_mul(user_staked_u128).ok_or(ErrorCode::MathOverflow)?
            .checked_div(RPS_MULTIPLIER).ok_or(ErrorCode::MathOverflow)?;
            
        let new_rewards_u64: u64 = new_rewards_u128.try_into().map_err(|_| ErrorCode::MathOverflow)?;
        
        user_staking.rewards_to_claim = user_staking.rewards_to_claim
            .checked_add(new_rewards_u64).ok_or(ErrorCode::MathOverflow)?;

        pool.total_unclaimed_rewards = pool.total_unclaimed_rewards
            .checked_add(new_rewards_u64).ok_or(ErrorCode::MathOverflow)?;
        
        user_staking.reward_per_share_user = pool.reward_per_share_global;
    }
    user_staking.last_update_time = current_time;

    Ok(())
}

fn __transfer_from_pool_authority(
    token_program: Program<'_, Token>, 
    pool_account: AccountInfo, 
    from: AccountInfo, 
    to: AccountInfo,
    pool_bump: u8,
    amount: u64,
) -> Result<()> {
    
    let seeds = &[
        b"pool".as_ref(),
        &[pool_bump]
    ];
    let signer = &[&seeds[..]];

    token::transfer(
        CpiContext::new_with_signer(
            token_program.to_account_info(),
            Transfer {
                from,
                to,
                authority: pool_account, 
            },
            signer,
        ),
        amount,
    )
}

fn __transfer_to_vault(
    token_program: Program<'_, Token>,
    owner: AccountInfo,
    from: AccountInfo,
    to: AccountInfo,
    amount: u64,
) -> Result<()> {
    
    token::transfer(
        CpiContext::new(
            token_program.to_account_info(), 
            Transfer {
                from,
                to,
                authority: owner,
            },
        ),
        amount,
    )
}


#[derive(Accounts)]
#[instruction(pool_bump: u8, max_dao_withdrawal_amount: u64, admin_fee_share_bps: u16, lockup_seconds: [i64; 3], sweep_threshold: u64)]
pub struct InitializePool<'info> {
    #[account(
        init,
        seeds = [b"pool".as_ref()], 
        bump = pool_bump,
        payer = initializer,
        space = 8 + std::mem::size_of::<PoolState>(),
    )]
    pub pool_state: AccountLoader<'info, PoolState>,
    
    #[account(
        init,
        token::mint = reward_mint,
        token::authority = pool_state,
        payer = initializer
    )]
    pub vault: Account<'info, TokenAccount>,
    #[account(
        init,
        token::mint = reward_mint,
        token::authority = pool_state,
        payer = initializer
    )]
    pub admin_fee_vault: Account<'info, TokenAccount>,
    #[account(
        init,
        token::mint = reward_mint,
        token::authority = pool_state,
        payer = initializer
    )]
    pub dao_treasury_vault: Account<'info, TokenAccount>,
    #[account(
        init,
        token::mint = reward_mint,
        token::authority = pool_state,
        payer = initializer
    )]
    pub defaulter_treasury_vault: Account<'info, TokenAccount>,

    pub governance_authority: UncheckedAccount<'info>,
    pub admin_authority: UncheckedAccount<'info>,
    pub lending_authority: UncheckedAccount<'info>,
    
    pub reward_mint: Account<'info, Mint>,
    #[account(mut)]
    pub initializer: Signer<'info>,
    pub token_program: Program<'info, Token>,
    pub system_program: Program<'info, System>,
    pub rent: Sysvar<'info, Rent>,
    pub clock: Sysvar<'info, Clock>,
}

#[derive(Accounts)]
pub struct SetPause<'info> {
    #[account(mut, has_one = governance_authority)]
    pub pool_state: AccountLoader<'info, PoolState>,
    pub governance_authority: Signer<'info>,
}

#[derive(Accounts)]
pub struct SetPendingChange<'info> {
    #[account(mut, has_one = governance_authority)]
    pub pool_state: AccountLoader<'info, PoolState>,
    pub governance_authority: Signer<'info>,
    pub new_authority_info: UncheckedAccount<'info>,
}

#[derive(Accounts)]
pub struct ClaimPendingChange<'info> {
    #[account(mut)]
    pub pool_state: AccountLoader<'info, PoolState>,
    pub claiming_authority: Signer<'info>,
    pub clock: Sysvar<'info, Clock>,
}

#[derive(Accounts)]
pub struct SweepVault<'info> {
    #[account(mut, has_one = governance_authority, has_one = vault, has_one = dao_treasury_vault, has_one = reward_mint)]
    pub pool_state: AccountLoader<'info, PoolState>,
    pub governance_authority: Signer<'info>,
    #[account(mut, token::authority = pool_state)] 
    pub vault: Account<'info, TokenAccount>,
    #[account(mut, token::authority = pool_state)] 
    pub dao_treasury_vault: Account<'info, TokenAccount>,
    pub reward_mint: Account<'info, Mint>,
    pub token_program: Program<'info, Token>,
}

#[derive(Accounts)]
pub struct WithdrawFromDaoTreasury<'info> {
    #[account(mut, has_one = governance_authority, has_one = dao_treasury_vault, has_one = reward_mint)]
    pub pool_state: AccountLoader<'info, PoolState>,
    pub governance_authority: Signer<'info>,
    #[account(mut, token::authority = pool_state)] 
    pub dao_treasury_vault: Account<'info, TokenAccount>,
    #[account(mut)]
    pub destination_ata: Account<'info, TokenAccount>,
    pub reward_mint: Account<'info, Mint>,
    pub token_program: Program<'info, Token>,
}

#[derive(Accounts)]
pub struct WithdrawFromAdminFee<'info> {
    #[account(mut, has_one = admin_authority, has_one = admin_fee_vault, has_one = reward_mint)]
    pub pool_state: AccountLoader<'info, PoolState>,
    pub admin_authority: Signer<'info>,
    #[account(mut, token::authority = pool_state)] 
    pub admin_fee_vault: Account<'info, TokenAccount>,
    #[account(mut)]
    pub destination_ata: Account<'info, TokenAccount>,
    pub reward_mint: Account<'info, Mint>,
    pub token_program: Program<'info, Token>,
}

#[derive(Accounts)]
#[instruction(pool_index: u8)]
pub struct InitializeUserStake<'info> {
    #[account(mut, has_one = reward_mint)]
    pub pool_state: AccountLoader<'info, PoolState>,
    #[account(
        init,
        seeds = [owner.key().as_ref(), pool_state.key().as_ref()],
        bump,
        payer = owner,
        space = 8 + std::mem::size_of::<UserStakingAccount>(),
    )]
    pub user_staking: AccountLoader<'info, UserStakingAccount>,
    #[account(mut)]
    pub owner: Signer<'info>,
    pub reward_mint: Account<'info, Mint>,
    pub system_program: Program<'info, System>,
    pub clock: Sysvar<'info, Clock>,
}

#[derive(Accounts)]
pub struct Deposit<'info> {
    #[account(mut, has_one = vault, has_one = reward_mint)]
    pub pool_state: AccountLoader<'info, PoolState>,
    #[account(mut, has_one = owner)]
    pub user_staking: AccountLoader<'info, UserStakingAccount>,
    #[account(mut)]
    pub owner: Signer<'info>,
    #[account(mut, token::mint = reward_mint)]
    pub user_source_ata: Account<'info, TokenAccount>,
    #[account(mut, token::mint = reward_mint, token::authority = pool_state)]
    pub vault: Account<'info, TokenAccount>,
    pub reward_mint: Account<'info, Mint>,
    pub token_program: Program<'info, Token>,
    pub clock: Sysvar<'info, Clock>,
}

#[derive(Accounts)]
pub struct UpdateUserPoolDuration<'info> {
    #[account(mut)]
    pub pool_state: AccountLoader<'info, PoolState>,
    #[account(mut, has_one = owner)]
    pub user_staking: AccountLoader<'info, UserStakingAccount>,
    pub owner: Signer<'info>,
    pub clock: Sysvar<'info, Clock>,
}

#[derive(Accounts)]
pub struct ClaimRewards<'info> {
    #[account(mut, has_one = vault, has_one = admin_fee_vault, has_one = reward_mint)]
    pub pool_state: AccountLoader<'info, PoolState>,
    #[account(mut, has_one = owner)]
    pub user_staking: AccountLoader<'info, UserStakingAccount>,
    #[account(mut)]
    pub owner: Signer<'info>,
    #[account(mut, token::mint = reward_mint, token::authority = pool_state)]
    pub vault: Account<'info, TokenAccount>,
    #[account(mut, token::mint = reward_mint, token::authority = pool_state)]
    pub admin_fee_vault: Account<'info, TokenAccount>,
    #[account(mut, token::mint = reward_mint)]
    pub user_rewards_ata: Account<'info, TokenAccount>,
    pub reward_mint: Account<'info, Mint>,
    pub token_program: Program<'info, Token>,
    pub clock: Sysvar<'info, Clock>,
}

#[derive(Accounts)]
pub struct Unstake<'info> {
    #[account(mut, has_one = vault, has_one = dao_treasury_vault, has_one = admin_fee_vault, has_one = reward_mint)]
    pub pool_state: AccountLoader<'info, PoolState>,
    #[account(mut, has_one = owner)]
    pub user_staking: AccountLoader<'info, UserStakingAccount>,
    #[account(mut)]
    pub owner: Signer<'info>,
    #[account(mut, token::mint = reward_mint, token::authority = pool_state)]
    pub vault: Account<'info, TokenAccount>,
    #[account(mut, token::mint = reward_mint, token::authority = pool_state)]
    pub dao_treasury_vault: Account<'info, TokenAccount>,
    #[account(mut, token::mint = reward_mint, token::authority = pool_state)]
    pub admin_fee_vault: Account<'info, TokenAccount>,
    #[account(mut, token::mint = reward_mint)]
    pub user_rewards_ata: Account<'info, TokenAccount>,
    pub reward_mint: Account<'info, Mint>,
    pub token_program: Program<'info, Token>,
    pub clock: Sysvar<'info, Clock>,
}

#[derive(Accounts)]
pub struct CloseStakingAccount<'info> {
    #[account(mut)]
    pub pool_state: AccountLoader<'info, PoolState>,
    #[account(mut, has_one = owner, close = owner)]
    pub user_staking: AccountLoader<'info, UserStakingAccount>,
    #[account(mut)]
    pub owner: Signer<'info>,
    pub clock: Sysvar<'info, Clock>,
}

#[derive(Accounts)]
#[instruction(new_lending_amount: u64)]
pub struct CollateralizeLending<'info> {
    #[account(has_one = lending_authority)]
    pub pool_state: AccountLoader<'info, PoolState>,
    #[account(mut)]
    pub user_staking: AccountLoader<'info, UserStakingAccount>,
    pub lending_authority: Signer<'info>,
    pub clock: Sysvar<'info, Clock>,
}

#[derive(Accounts)]
#[instruction(amount: u64)]
pub struct DecollateralizeLending<'info> {
    #[account(has_one = lending_authority)]
    pub pool_state: AccountLoader<'info, PoolState>,
    #[account(mut)]
    pub user_staking: AccountLoader<'info, UserStakingAccount>,
    pub lending_authority: Signer<'info>,
    pub clock: Sysvar<'info, Clock>,
}

#[derive(Accounts)]
pub struct ForceUnlockCollateral<'info> {
    #[account(mut, has_one = lending_authority, has_one = vault, has_one = defaulter_treasury_vault, has_one = reward_mint)]
    pub pool_state: AccountLoader<'info, PoolState>,
    #[account(mut)]
    pub user_staking: AccountLoader<'info, UserStakingAccount>,
    pub lending_authority: Signer<'info>,
    #[account(mut, token::mint = reward_mint, token::authority = pool_state)]
    pub vault: Account<'info, TokenAccount>,
    #[account(mut, token::mint = reward_mint, token::authority = pool_state)]
    pub defaulter_treasury_vault: Account<'info, TokenAccount>,
    pub reward_mint: Account<'info, Mint>,
    pub token_program: Program<'info, Token>,
    pub clock: Sysvar<'info, Clock>,
}

#[account(zero_copy)]
#[repr(packed)] 
pub struct PoolState {
    pub is_initialized: bool,
    pub global_pause: bool,
    
    pub pool_bump: u8,
    pub vault_bump: u8,
    pub admin_fee_vault_bump: u8,
    pub dao_treasury_vault_bump: u8,
    pub defaulter_treasury_vault_bump: u8, 
    [padding_params] : [u8; 6],
    
    pub governance_authority: Pubkey,
    pub admin_authority: Pubkey,
    pub lending_authority: Pubkey,
    pub pending_governance_authority: Pubkey,

    pub reward_mint: Pubkey,
    pub vault: Pubkey,
    pub admin_fee_vault: Pubkey,
    pub dao_treasury_vault: Pubkey,
    pub defaulter_treasury_vault: Pubkey,

    pub pending_change_time: i64,
    pub last_reward_time: i64,

    pub max_dao_withdrawal_amount: u64,
    pub sweep_threshold: u64,
    pub admin_fee_share_bps: u16,
    [padding_params_lockup] : [u8; 6], 
    pub lockup_seconds: [i64; 3],

    pub reward_per_share_global: u128,
    pub total_staked_amount: u64,
    pub total_unclaimed_rewards: u64,
    
    pub dao_withdrawal_24h_cap: u64, 
    pub dao_withdrawal_reset_time: i64,

    [padding_final] : [u8; 96],
}

#[account(zero_copy)]
#[repr(packed)]
pub struct UserStakingAccount {
    pub is_initialized: bool,
    pub stake_bump: u8,
    pub pool_index: u8,
    [padding_a]: [u8; 5], 

    pub owner: Pubkey,
    
    pub staked_amount: u64,
    pub lockup_end_time: i64,

    pub reward_per_share_user: u128,
    pub rewards_to_claim: u64,
    pub pending_rewards_due_to_limit: u64,

    pub lending: u64,
    pub lending_unlock_time: i64,

    pub last_update_time: i64,
    
    [padding_final] : [u8; 104],
}

#[error_code]
pub enum ErrorCode {
    #[msg("Account already initialized.")]
    AlreadyInitialized,
    #[msg("Invalid pool index provided.")]
    InvalidPoolIndex,
    #[msg("Staked amount must be greater than zero.")]
    ZeroStakedAmount,
    #[msg("Amount must be greater than zero.")]
    ZeroAmount,
    #[msg("Lockup duration is shorter than current lockup.")]
    LockupTooShort,
    #[msg("Lockup period has not expired.")]
    LockupNotExpired,
    #[msg("Cannot reset the lockup time because the current lockup is still active.")] 
    LockupStillActive,
    #[msg("Global pause is active.")]
    GlobalPause,
    #[msg("Insufficient stake to cover collateral amount.")]
    InsufficientStake,
    #[msg("Cannot unstake collateralized tokens.")]
    CollateralLock,
    #[msg("Collateral is locked because the grace period has expired.")]
    CollateralLockedAtRisk,
    #[msg("Math Overflow occurred.")]
    MathOverflow,
    #[msg("Math Underflow occurred.")]
    MathUnderflow,
    #[msg("Insufficient tokens in the vault for transfer.")]
    InsufficientVaultBalance,
    #[msg("Too much free tokens in the vault, amount is too large for sweep.")]
    AmountTooLarge,
    #[msg("Invalid input parameter.")]
    InvalidInput,
    #[msg("No pending governance change.")]
    NoPendingChange,
    #[msg("Timelock period for governance change has not expired.")]
    TimeLockNotExpired,
    #[msg("Stake still exists in the account. Must unstake all before closing.")]
    StakeStillExists,
    #[msg("Cannot modify collateral after the lending grace period has expired.")]
    GracePeriodExpired,
    #[msg("Lending collateral is zero.")]
    ZeroCollateral,
    #[msg("Lending grace period has not expired yet.")]
    GracePeriodNotExpired,
    #[msg("DAO daily withdrawal limit reached.")]
    DaoLimitReached,
    #[msg("Duplicate accounts passed in instruction.")] 
    DuplicateVaults, 
    #[msg("Unauthorized access.")]
    Unauthorized,
    #[msg("Token account uses an invalid mint.")]
    InvalidTokenMint, 
    #[msg("Insufficient collateral staked in the user account.")] 
    InsufficientCollateral, 
    #[msg("Invalid amount for operation.")]
    InvalidAmount,
    #[msg("The initial stake amount is too small to prevent precision attacks.")]
    InitialStakeTooSmall,
    #[msg("Token account has an invalid owner.")]
    InvalidAccountOwner,
}

